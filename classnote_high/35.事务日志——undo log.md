redo log是事务持久性的保证,undo log是事务原子性的保证,在事务中更新数据的前置操作其实是要先写入一个undo log

1.undo log的作用
    - 回滚数据
        undo log通过记录逆操作的方式可以在异常情况下将事务回滚,恢复数据到初始状态,但需要注意,所有的修改只是被逻辑地取消,但是数据结构和页半身在回滚之后可能
      有所不同,比如我们想插入一条数据,但此时当前页刚好满了,需要额外申请一个页,那么这种回滚了以后实际上只是根据undo log将该记录删除,但是这个页已经申请了,
      并不会把页也给销毁;
    - MVCC
        undo的另一个作用是MVCC,即在InnoDB存储引擎中MVCC的实现是通过undo来完成的,当用户读取完一行记录时,若该记录已经被其他事务占用,当前事务可以通过undo
      读取之前的行版本信息,以此实现非锁定读取; 该部分后面在MVCC处详细介绍

2.回滚段中的数据分类
    - 未提交的回滚数据
    - 已经提交但未过期的回滚数据
    - 事务已经提交并过期的

3.InnoDB行格式中的三个隐藏列
    - DB_ROW_ID: 如果没有为表显式的定义主键,并且表中也没有定义唯一索引,那么InnoDB会自动为表添加一个row_id的隐藏列作为主键;
    - DB_TRX_ID: 每个事务都会分配一个事务ID,当对某条记录发生变更时,就会将这个事务的事务ID写入trx_id中;
                (需要注意:这里说的是变更而不是提交,即一个事务即使修改了数据但并没有commit,这个列的数据一样会变化,这点需要清除)
    - DB_ROLL_PTR: 回滚指针,本质上就是指向undo log的指针;

4.具体的undo log生成过程见PDF [](/pdf/第14章_MySQL事务日志.pdf)
    在这我简单说一下我个人认为的关键点,事务回滚主要是依赖于回滚指针,我们这里分情况来简单介绍一下
    1)比较典型的更新操作,将表中的某行数据全部进行了更新,那这种情况,会按照顺序,依次用回滚指针进行连接,先进行的操作会放在链尾,后进行的操作放在roll_ptr之后,
      举个例子:加入我们对一行的name,age和mark三个字段都要进行修改,当我们修改name,那么此时会生成一条undo log(用来记录当前更新操作的逆操作),然后我们的
      roll_ptr会指向该条undo log;接下来操作age,同样也会生成一条记录更新age的逆操作的undo log,注意,此时这条age的undo log将指向name的undo log,
      而age的undo log将由我们行中的ROLL_PTR指向,这样就可以实现先进行的操作最后回滚,后进行的操作先回滚;
    2)删除操作,删除操作需要我们回忆一下之前将行格式中的一个属性,delete_mask(用于标记记录删除,但为了保持结构而暂时没有真正删除);
      当我们试图删除一条数据时,我们会将该条数据的delete_mask修改为1,同时roll_ptr指针指向这条数据记录的undo log,如果后续回滚,就将通过指针找到该条记录,
    然后将其的delete_mask再修改为0;
    3)新增操作比较简单,只需要将逆操作记录在undo log中,如果需要回滚直接执行逆操作即可; 