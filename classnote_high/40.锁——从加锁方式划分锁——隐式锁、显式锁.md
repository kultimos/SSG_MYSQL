1.隐式锁
    我们之前提到过,一般情况下,新插入一条记录的操作并不加锁,通过一种称之为隐式锁的结构来保护这条新插入的记录在事务提交前不被别的事务访问;
    隐式锁之所以叫隐式,就是因为我们通过 select * from performance_schema.data_locks\G; 是查不到这个锁的
    隐式锁会在两种情况下变为显式锁

2.隐式锁会变为的两种情景
    情景一:
      对于聚簇索引,有一个trx_id隐藏列,用于记录最后改动该记录的事务id;如果我们当前在事务一中进行插入操作,那么该记录的trx_id就会记录
    事务一的id,这时实际上该记录就拥有了一个隐式锁,如果之后这条记录就commit了,那这个隐式锁也就释放了,对于我们来说,实际上是完全不感知的;
    但是如果在事务一还未提交的时候,事务二也想要对该记录进行操作,这时事务二首先会获取该记录的trx_id记录的事务id,再将trx_id与事务一的id
    进行比较,如果一致,事务二就会为事务一创建一个X锁(is_waiting为false),同时为自己也创建一个锁结构(is_waiting为true),需要注意,此时
    事务二的操作会被阻塞,进入等待状态,而此时事务一持有的也不再是隐式锁,已经升级为显式锁,
    可以使用 select * from performance_schema.data_locks\G; 查到;
    　
    情景二:
      如果是二级索引,本身并没有trx_id列,但是在二级索引页面的Page Header部分有一个PAGE_MAX_TRX_ID属性,代表最近一次对页面做改动的事务ID,
    如果该事务ID小于事务一和事务二的事务id,说明目前并没有事务操作该页面;那如果事务一此时执行了insert操作,自然就会发现PAGE_MAX_TRX_ID跟
    事务一的事务id一致,那么会先通过回表找到该记录的聚簇索引,然后获取事务一的trx_id和记录的trx_id,之后操作如情景一相同;之所以回表,是为了给
    记录加锁,二级索引中并没有行记录,所以需要先比较事务id,然后回表,回表后在比较具体行记录的事务id,最后再加锁;

3.小结隐式锁
    隐式锁的产生是因为我们的insert操作性,为了避免出现两个事务,一个事务插入数据未提交时,另一个事务就进行查询而出现脏读问题,mysql为我们提供了
  隐式锁;隐式锁在只有一个事务进行insert时,我们是完全不感知的,但是如果有个事务插入数据未提交时,另一个事务查询该记录,就会将插入数据的事务持有的隐式锁
  升级为显式X锁,同时自己为自己创建一个锁结构,并进入阻塞状态;
    而过程中对于是否有其他事务正在操作记录,可以通过行记录中的隐藏列trx_id进行判断,如果当前的活动事务id均大于trx_id,就说明目前没有事务在针对该记录做操作,
  而如果trx_id恰好等于当前的一个活动事务A的id,就说明该事务A在操作记录,那如果再有事务B试图操作记录,就会出现活动事务A隐式锁升级为显式锁和事务B自创锁结构
  并进入阻塞状态的现象;
    
    