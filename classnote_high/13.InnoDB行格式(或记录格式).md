1.COMPACT行格式
    主要有三部分组成
    - 变长字段长度列表
        MYSQL定义一些变长的数据类型,比如VARCHAR、VARBINARY、TEXT、BLOB类型,这些数据类型修饰列称为变长字段,变长字段中存储多少字节的数据不是固定的,
      所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来;[在Compact行格式中],把所有变长字段的真实数据占用的字节长度都存放在记录的开头
      部位,从而形成一个变长字段长度列表(注意:存储变长字段的顺序和字段所在列在数据表结构中的顺序是恰好相反的)
    - NULL值列表
        Compact行格式会把可以为NULL的列统一管理起来,存在一个标记为NULL值列表中;如果表中没有允许存储NULL的列,则NULL值列表也就不存在了;
        Q:为什么要定义NULL值列表?
          之所以要存储NULL是因为数据都是需要对齐的,如果没有标注出来NULL值的位置,就有可能在查询数据的时候出现混乱;如果使用一个特殊的符号放到对应的数据位
        表示空置的话,虽然能达到效果,但是这样很浪费空间,所以直接就在行数据的头部开辟出一块空间专门用来记录该行数据哪些是空数据,哪些是非空数据;
          格式:二进制位的值为1时,表示该列的值为NULL;二进制位的值为0时,表示该列的值不为NULL
          注意:NULL值列表中不会记录主键和已经明确声明为不为null的列的记录,并且NULL值列表的顺序也是和字段所在列在数据表中的顺序是相反的
        ![img.png](变长字段长度列表和NULL值列表示意图.png)
    - 记录头信息
        [39行开始](12.页的内部结构——七个组成部分.md)
    - 记录的真实数据
        记录的真实数据中除了数据表中定义的列的数据以外,还会有三个隐藏列,需要清楚只有聚簇索引中会有这三个字段,普通的二级索引是没有transaction_id的,
      普通的二级索引是依赖于二级索引页面的Page Header中的PGAE_MAX_TRX_ID,该属性表示对该页面做出改动的最大事务ID,即是最近一次改动的事务ID,需要注意
      即使事务没有提交,但是数据改动了,也会被记录,是最近一次改动的事务ID而不是最近一次提交的事务ID!
        - row_id  行ID,唯一标识一条记录,但这是一个非必须字段
            之前我们在学习聚簇索引的时候曾经提到,当一个表有主键便以主键来构建聚簇索引,如果没有主键,则会选一个unique的列作为主键,如果连unique的列也没有,
          Innodb会隐式的定义一个主键来构建聚簇索引,这个隐式的主键就是row_id,所以也可以理解row_id仅在这种情况才会被创建,如果已经有主键或unique的列,
          row_id则不会被创建;
        - transaction_id  事务ID,必须字段
        - roll_pointer  回滚指针,必须字段
        transaction_id和roll_pointer会在之后事务的部分进行讲解 [请跳转](35.事务日志——undo%20log.md)

2.Dynamic和Compressed行格式(MYSQL5.7和MYSQL8.0中默认使用的行格式都是Dynamic)
    Dynamic和Compressed与我们Compact行格式在上述关于Compact的详细介绍中的内容是一致的;不过在行溢出的处理上有一些区别
    - 行溢出
        InnoDB中一个页的大小是16KB即16384个字节,而一个VARCHAR类型的列最多可以存储65533个字节,这样就可能出现一个页存放不了一条记录,
      这种现象就称为行溢出
        在Compact和Reduntant行格式中,对于行溢出的列,会采取在当前页存放一部分数据,然后将剩余数据分散存储到其他几个页中,然后这些页中会
      开辟空间用于存储指向下一页的地址
        Dynamic和Compressed两种行格式采取的是完全溢出即并不会像Compact一样在当前页存放一部分数据,而是将所有数据都放到溢出页中;此外,
      Compressed行记录的另一个功能是可以对存储的行数据以zlib的算法进行压缩,因此对于BLOB、TEXT/VARCHAR这类大长度类型数据的存储非常有效;

3.Redundant行格式
    Redundant行格式是MYSQL5.0版本之前InnoDB使用的行格式![img.png](Redundant行格式示意图.png)
    可以发现想必于2上面几种行格式,
      1)Redundant行格式的开头是字段长度偏移列表
        - 少了"变长"两个字:Redundant行格式会把该条记录中所有列(包括隐藏列)的长度信息都按照逆序存储到字段长度偏移列表中,冗余
        - 多了"偏移"两个字:这意味着计算列值长度的方式不再像Compact行格式那么直观,而是采用两个相邻数值的差值来计算各个列值的长度
      2)并且并没有NULL值列表
    此外相比于上述几种,Reduntant的记录头信息要占6个字节,多出了n_fields和1byte_offs_flag两个属性,减少了record_type这个属性
        - n_fields 记录中列的数量
        - 1byte_offs_flag 记录字段长度偏移列表中每个列对应的偏移量使用1个字节还是2个字节表示
    其他场景都是与上述几种行格式都是一致的