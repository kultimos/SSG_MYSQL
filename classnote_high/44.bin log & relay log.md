1.bin log概念
    binlog即binary log,二进制日志文件,也叫作变更日志;它记录了数据库所有执行的DDL和DML等数据库更新事件的语句,但是不包含没有修改任何数据的语句
  即不包含查询语句(如select,show等);
    它是以事件形式记录并保存在二进制文件中,通过这些信息,我们可以再现数据更新操作的全过程;

2.bin log主要应用场景
    [一是用于数据恢复],如果Mysql数据库意外停止,可以通过二进制日志文件来查看用户执行了哪些操作,对数据库服务器文件做了哪些修改,然后根据二进制日志文件
  中的记录来恢复数据库服务器
    [二是用于数据复制],由于日志的延续性和时效性,master把它的二进制日志传递给slaves来达到master-slaves数据一致的目的;
    可以说Mysql数据库的数据备份、主备、主主、主从都离不开bin log,需要依靠binlog来同步数据,保证数据一致性

3.bin log的写入机制
    再执行事务过程中,先把日志写到binlog cache,事务提交时,再把binlog cache写入到文件系统page cache中,再由page cache同步到磁盘上的binlog文件中,
  并且需要注意,一个事务的binlog不能被拆分,即使当前cache已经达到参数的最大值,也会继续写入cache,直到当前事务完全写入cache,cache允许在这种情况下大小
  超出参数值;
    我们将cache写入文件系统中的过程称为write,文件系统刷盘的过程称为fsync,我们可以通过参数sync_binlog控制,默认是0,为0的时候表示每次提交事务都只write,
  由系统自行判断什么时候执行fsync,这种方案性能比较好,但如果操作系统宕机,文件系统中的binlog数据会丢失;
    为了安全起见,我们可以将sync_binlog参数设置为1,表示每次提交事务都会执行write+fsync,其实跟我们redo log刷盘的策略相同,都是最大限度的保证数据安全;

4.细分bin log和redo log的区别:
    我们现在有一个事务,当事务开始执行,实际上redo log已经开始记录了,redo log本身的执行顺序就是先将修改后的数据信息写入到redo log buffer中,再由
  redo log buffer更新到文件系统中,到这一步我们就默认已经完成redolog的持久化了,因为操作系统的宕机是很少见的,到此为止都是在事务执行过程中做完的,
  而且也只有这些做完了,用户才能感知到,事务提交了;
    而bin log虽然也会在事务执行期间将操作记录在cache中,但是只有在事务commit后,才会执行将cache中内容写入到文件系统和同步到磁盘的步骤,我们还是一样
  认为写入文件系统就代表binlog持久化,那么也还是需要事务commit为前提,从结果上看,就是redo log在事务执行期间一直在记录,而bin log是在事务提交时才开始
  记录,这本质上是因为二者的目的本就不同,redo log的目的是为了确保在系统崩溃或故障发生时,可以通过redo log来恢复数据的一致性(内存磁盘之间的数据一致性),
  所以,内存数据一旦发生变更,就会把改动更新到磁盘,所以会在事务执行过程中一直记录;而bin log的目的是为了记录数据库的详细操作,以便进行数据库备份、恢复、
  复制和故障恢复等操作;

5.bin log的二阶段提交(分布式场景才有此形式)
    我们已经清晰了bin log和redo log之间的写入时间的差异,一个是在事务执行过程中,一个是在事务提交时,那么有没有这样一种可能,redo log刷盘完毕,事务提交,
  然后bin log还没来得及写入或者写入了一部分但没完全写入,此时mysql挂了,那么这时会出现什么问题,在分布式场景中,我们主机恢复时利用redo log,拿到了
  redo log中的数据,而从机通过bin log进行数据恢复,很明显,因为bin log中实际上并没有记录上一个事务进行的数据更改,所以现在主从节点出现了数据不一致,为此,
  InnoDB引擎使用两阶段提交方案来解决类似上述问题的分布式事务问题;
    ![最后通过commit阶段和binlog共同决定是否提交事务](二阶段提交判断示意图.png)
    二阶段提交指的是将redolog分为两个阶段,prepare阶段和commit阶段,其中prepare阶段会在事务执行过程中发生,会将相关数据的改动存入到redo log buffer中,
  二阶段commit则会在提交事务时和binlog同步进行,commit会将buffer中的数据存入到文件系统中,然后再最终提交事务时,会进行判断;
    情况一:binlog异常,根据[二阶段提交判断示意图]可知,会回滚事务
    情况二:binlog和commit都正常,提交事务   
    情况三:commit异常,但binlog正常,这种情况不会回滚事务;为什么?因为首先我们的目的是保证binlog和redolog的数据一致性,那么现在binlog有了,说明我们redolog
          的prepare阶段已经ok了,也就是说我们现在差的只有将redolog buffer中的数据刷盘到文件系统中即commit这一步,那我们没必要回滚事务啊,这次commit挂了,
          没关系啊,反正binlog和redolog的prepare都OK了,我们就再一次提交事务然后利用redolog恢复数据即可啊;
    　
    注意:只有在分布式系统中,为了保证多个节点之间的数据一致性,才会应用到二阶段提交,在单台机器上,redo log会在事务执行过程中将修改操作持久化到磁盘,而不需要拆分为两个阶段;

6.中继日志(relay log)
    中继日志只在主从服务器架构的从服务器上存在;
    从服务器为了与主服务器保持一致,要从主服务器读取二进制日志的内容,并且把读取到的信息写入本地的日志文件中,这个从服务器本地的日志文件就叫中继日志;