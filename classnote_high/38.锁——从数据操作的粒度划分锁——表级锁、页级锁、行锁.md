从数据操作的粒度划分: 表级锁、页级锁、行锁

1.表锁
    该锁会锁定整张表,它是MYSQL中最基本的锁策略,并不依赖于存储引擎(无论你是MYSQL的什么存储引擎,对于表锁的策略都是一样的),并且表锁是开销最小的策略(因为粒度比较大),
  由于表级锁一次会将整个表锁定,所以可以很好的避免死锁的问题;当然,锁的粒度所带来的最大的负面影响就是出现锁资源争用的概率也会最高,导致并发率大打折扣;
　
    - 表级别的S锁、X锁
        一般情况下,不会使用到InnoDB存储引擎提供的表级别的S锁和X锁,InnoDB更厉害的还是更细粒度的行锁,关于表级别得X锁和S锁大概了解即可,[](/pdf/第15章_锁.pdf)
　
    - 意向锁
        InnoDB支持多粒度锁,它允许行级锁和表级锁共存,而意向锁就是其中一种表锁;在数据表的场景中,如果我们给一行数据加上了排它锁,数据库会自动给更大一级的空间,比如数据页或
      数据表加上意向锁,告诉其他人这个数据页或数据表已经有人上过排它锁了,这样当其他人想要获取数据表排它锁的时候,只需要了解是否有人已经获取了这个数据表的意向排他锁即可;
        意向锁是由存储引擎自己维护的,用户无法手动操作意向锁,在为数据行添加共享/排它锁时,InnoDB会自动添加该数据行所在数据表的对应意向锁;即如果我们给一行数据添加了一个
      共享锁/排它锁,实际上生成了两把锁,一把是我们声明的数据行的锁,另一个是InnoDB为我们生成的该数据行所在数据表的意向锁,我们添加的是排它锁,那么生成的就是意向排它锁,我们  
      声明的是共享锁,那么生成的就是意向共享锁;
　
      1)意向锁要解决的问题 
        现在有两个事务,分别是T1和T2,其中T2试图在该表级别上应用共享或排它锁,如果没有意向锁存在,那么T2就需要去检查每个页或行是否存在锁,效率很低;如果存在意向锁,那么此时
      就会受到由T1控制的表级别意向锁的阻塞,T2在锁定该表之前就不用检查各个页或行锁,而只需要检查表上的意向锁;
　
      2)意向锁的类型
         - 意向共享锁
         - 意向排它锁
　
      3)小结意向锁
         - InnoDB支持多粒度锁,特定场景下,行级锁可以与表级锁共存(行级排它锁和表级意向排他锁)
         - 意向锁之间互不排斥,但除了共享锁和意向共享锁之外,意向排它锁会与表级 共享锁/排它锁 互斥,意向共享锁也与排它锁互斥;
         - 意向锁是一种不与行级锁冲突的表级锁,意向共享锁和意向排他锁不会和行级的共享锁/排他锁发生冲突,只会与表级的共享锁/排他锁冲突;
         - 意向锁在保证并发性的前提下,实现了行锁和表锁共存且满足事务隔离性的要求;
　
    - 自增锁
        自增锁是一个表级别锁,具象化的体现就是我们通常会在一些表中为主键设置auto increment,但是如果多个事务同时向该表插入数据,如何保证主键的唯一性呢?靠的就是我们的自增锁,
      也可以说明自增锁是一个表级锁;
        有三种锁定模式模式,而数据插入也有三种方式,下面我们一起介绍一下
        插入方式:简单插入、批量插入和混合模式插入
        简单插入指:插入时确定了要插入的行数、批量插入指:插入时不知道要插入的行数、混合模式插入指:insert into table (id,name) values(1,'a'),(NULL,'B'),(5,'c'),(NULL,'D')
      这种只指定了部分的id值,其余部分的id值需要依赖于auto increment,这就是混合模式插入,混合模式插入还有一种情况即向表中插入数据时发现唯一键已经存在数据,则会更新存在行数据;
        三种锁定模式:
         - 传统锁定模式
            在此锁定模式下,所有类型的insert语句都会获得一个特殊的表级自增锁,多事务执行时并发性差
         - 连续锁定模式(MYSQL8.0前的默认模式)
            对于批量插入来说,连续锁定和传统锁定没有区别,每一次insert都会加锁,但是对于简单插入来说,因为事先是知道要插入多少条数据的,所以在获取了自增锁之后就可以得到需要的自增区间,然后
         就可以释放自增锁了,即需要获取一次自增锁来得到自增区间,但是真正的添加数据时并不需要持有自增锁,而是依靠一开始获取自增锁时获得的自增区间来实现数据插入;需要注意该模式下在最开始是
         需要获取自增锁的,所以如果自增锁此时被其他事务持有,那么即使是简单插入,此刻也会进入等待锁的阻塞状态;
         - 交错锁定模式(MYSQL8.0后的默认模式)
            在此模式下,所有类型的插入语句都不会持有自增锁,并发性max,自动递增值保证在所有并发执行的所有类型的insert语句中是唯一且单调递增的,
          但是由于多个语句可以同时生成数字,所以为任何给定语句插入的行生成的值可能不是连续的;
        三种锁定模式依赖于属性innodb_autoinc_lock_mode,0传统锁定、1连续锁定、2交错锁定;
　
    - 元数据锁
        无需显式使用,都是MYSQL自动加的;
        元数据锁意在保证读写的正确性;
        当我们对数据库进行增删改查时都会隐式的给我们当前的事务添加一个DML读锁,DML的读锁可以共享,所以可以多个事务对表进行查询,但如果我们想要修改表结构,实际上会为事务分配一个DML写锁,
      而这个DML写锁会阻塞其他试图获取DML读锁的事务,这是为了避免在一个事务中多次查询发现表结构都不同的尴尬情况;
        对一个表进行数据的增删改查时,加DML读锁;当对表的结构作出变更操作时,加DML写锁,DML读锁共享,DML写锁会阻塞DML读锁;
        注意这里纬度的区别,增删改查是对数据而并没有改变表结构,所以是DML读锁,只有对表结构做出了改变才会加DML写锁;

2.行锁
    InnoDB与MyISAM的最大不同有两点:一是支持事务、二是采用了行级锁
    行级锁的优点是:锁定力度小,发生锁冲突概率低,可以实现的并发度高;缺点则是:锁的开销比较大,加锁会比较慢,容易出现死锁情况;
    　
    - 记录锁(LOCK_REC_NOT_GAP)
        记录锁就是仅仅把一条记录锁上,对周围的数据没有影响;
        需要注意记录锁也是有S锁和X锁之分的,称为S型记录锁和X型记录锁,原理也与之前介绍的表级X锁、S锁一致
          当一个事务获取了一条记录的S型记录锁之后,其他事务也可以继续获取该记录的S型记录锁,但不可以继续获取X型记录锁;
          当一个事务获取了一条记录的X型记录锁之后,其他事务既不可以继续获取该记录的S型记录锁,也不可以继续获取X型记录锁;
　
    - 间隙锁(Gap Locks)
        用加锁在解决幻读时会有一个问题,幻读的成因是查数据时没查到,但是插入数据时显示数据已存在,那这种情况我们是无法加记录锁的,因为
      我们无法给一条我们无法感知、无法查到的记录加锁;间隙锁就是用来解决这个问题的,间隙锁针对的只有插入操作！
        我们用数据举例来帮我们更好理解间隙锁的意义,我们有一个表student,有五条数据,id分别是:1,3,8,15,20;幻读呢,是因为两个事务,
      一个查一个改造成的,假如我们事务一:select * from student where id = 4,ok,没有数据,那我要插入了;就在此刻,事务一查询完,
      还未insert的时候,事务二直接一个:insert into student(id) values(4);然后事务一开始插入就会发现,已存在id为4的数据,上述
      是没有间隙锁时出现的幻读情况;
        接下来我们讲一下有了间隙锁以后的情况:事务一:select * from student where id = 4,ok,没有数据,不过再执行这条语句后,InnoDB
      就会自动给当前的id为4的这行数据添加一个间隙锁;事务二来了:select * from student where id = 4,是否会阻塞？并不会,间隙锁
      只针对insert生效,所以并不会影响其他事务读取该行数据,所以这里事务二也会发现id为4并没有数据,然后他想插入数据了,却发现被阻塞了;
        上面已经介绍了有了间隙锁后为何可以阻止幻读的发生,接下来要具体介绍一下间隙锁的机制:
        - 间隙锁也分读锁和写锁,只不过区分二者的意义不大,对于读操作间隙锁等于没有,而对于写操作,只要一行数据有间隙锁,那么就会被阻塞;
        - 间隙锁之所以叫间隙锁是因为他不光会给一行数据加锁,而是会给mysql数据间隙之间的所有行加锁,上述的例子中我们查id=4的数据,实际
        上加锁的区间是开区间(3,8),为什么?因为3和8是距离4最近的两条真实记录,如果我们查的数据是id=9,那么间隙锁会上锁的区间就是开区间
        (8,15),那如果我们查询的id=21？其实一样,最近的两条数据只有20,那就是(20,正无穷);
　
        间隙锁会导致死锁问题      
            间隙锁对读操作没有限制,那么就会出现这样一种情况,两个事务查id=4的记录,ok,都查到没有数据,那么两个事务都会对(3,8)区间
          各自持有一把间隙锁,那事务一现在去插入数据,很明显会被事务二的间隙锁阻塞,同理,事务二去插入一条数据,也会被事务一的间隙锁阻
          塞,事务一和事务二都需要对方释放间隙锁,这就是死锁现象了;
            至于死锁现象后续会如何处理就是死锁部分介绍要解决的问题了,我们需要认识到间隙锁有可能导致死锁的问题即可;
　
    - 临键锁
        临建锁本质是记录锁和间隙锁的合体,它既可以保护该条记录,又能阻止别的事务将新纪录插入被保护记录前面的间隙;
        五条数据1,3,8,15,20,如果我们给8上一个临键锁,实际上此刻上锁的区间是(3,8],注意了,结尾是闭区间,即8这条记录本身也被锁定;  
        InnoDB默认的锁就是临键锁
　
    - 插入意向锁
        我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了gap锁(间隙锁或临键锁),如果有的话,插入操作需要等待,
      直到拥有gap锁的那个事务提交,而InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构,表名有事务想在某个间隙中插入新纪录,
      但是现在在等待,InnoDB就把这种类型的锁命名为Insert Intention Locks,我们称为插入意向锁
        需要注意几点:
        - 插入意向锁是一种间隙锁而不是意向锁,在insert操作时产生
        - 插入意向锁相互并不排斥,即使多个事务在同一间隙区间插入多条记录,只要记录本身(主键、唯一索引)不冲突,那么事务之间就不会出现冲突等待;
        - 插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁
        个人理解:为什么插入意向锁是间隙锁,可能是因为插入意向锁的竞争对象是间隙锁,如果没有间隙锁实际上也就没有插入意向锁出现的场景了,
               而当插入意向锁存在时,也是等待间隙锁释放才可以成功插入,从竞争的角度上来说,同类型锁互相竞争是确实比较合理的;






