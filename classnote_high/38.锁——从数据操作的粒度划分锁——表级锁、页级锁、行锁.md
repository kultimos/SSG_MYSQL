从数据操作的粒度划分: 表级锁、页级锁、行锁

1.表锁
    该锁会锁定整张表,它是MYSQL中最基本的锁策略,并不依赖于存储引擎(无论你是MYSQL的什么存储引擎,对于表锁的策略都是一样的),并且表锁是开销最小的策略(因为粒度比较大),
  由于表级锁一次会将整个表锁定,所以可以很好的避免死锁的问题;当然,锁的粒度所带来的最大的负面影响就是出现锁资源争用的概率也会最高,导致并发率大打折扣;
　
    - 表级别的S锁、X锁
        一般情况下,不会使用到InnoDB存储引擎提供的表级别的S锁和X锁,InnoDB更厉害的还是更细粒度的行锁,关于表级别得X锁和S锁大概了解即可,[](/pdf/第15章_锁.pdf)
　
    - 意向锁
        InnoDB支持多粒度锁,它允许行级锁和表级锁共存,而意向锁就是其中一种表锁;在数据表的场景中,如果我们给一行数据加上了排它锁,数据库会自动给更大一级的空间,比如数据页或
      数据表加上意向锁,告诉其他人这个数据页或数据表已经有人上过排它锁了,这样当其他人想要获取数据表排它锁的时候,只需要了解是否有人已经获取了这个数据表的意向排他锁即可;
        意向锁是由存储引擎自己维护的,用户无法手动操作意向锁,在为数据行添加共享/排它锁时,InnoDB会自动添加该数据行所在数据表的对应意向锁;即如果我们给一行数据添加了一个
      共享锁/排它锁,实际上生成了两把锁,一把是我们声明的数据行的锁,另一个是InnoDB为我们生成的该数据行所在数据表的意向锁,我们添加的是排它锁,那么生成的就是意向排它锁,我们  
      声明的是共享锁,那么生成的就是意向共享锁;
　
      1)意向锁要解决的问题 
        现在有两个事务,分别是T1和T2,其中T2试图在该表级别上应用共享或排它锁,如果没有意向锁存在,那么T2就需要去检查每个页或行是否存在锁,效率很低;如果存在意向锁,那么此时
      就会受到由T1控制的表级别意向锁的阻塞,T2在锁定该表之前就不用检查各个页或行锁,而只需要检查表上的意向锁;
　
      2)意向锁的类型
         - 意向共享锁
         - 意向排它锁
　
      3)小结意向锁
         - InnoDB支持多粒度锁,特定场景下,行级锁可以与表级锁共存(行级排它锁和表级意向排他锁)
         - 意向锁之间互不排斥,但除了共享锁和意向共享锁之外,意向排它锁会与表级 共享锁/排它锁 互斥,意向共享锁也与排它锁互斥;
         - 意向锁是一种不与行级锁冲突的表级锁,意向共享锁和意向排他锁不会和行级的共享锁/排他锁发生冲突,只会与表级的共享锁/排他锁冲突;
         - 意向锁在保证并发性的前提下,实现了行锁和表锁共存且满足事务隔离性的要求;
　
    - 自增锁
        自增锁是一个表级别锁,具象化的体现就是我们通常会在一些表中为主键设置auto increment,但是如果多个事务同时向该表插入数据,如何保证主键的唯一性呢?靠的就是我们的自增锁,
      也可以说明自增锁是一个表级锁;
        有三种锁定模式模式,而数据插入也有三种方式,下面我们一起介绍一下
        插入方式:简单插入、批量插入和混合模式插入
        简单插入指:插入时确定了要插入的行数、批量插入指:插入时不知道要插入的行数、混合模式插入指:insert into table (id,name) values(1,'a'),(NULL,'B'),(5,'c'),(NULL,'D')
      这种只指定了部分的id值,其余部分的id值需要依赖于auto increment,这就是混合模式插入,混合模式插入还有一种情况即向表中插入数据时发现唯一键已经存在数据,则会更新存在行数据;
        三种锁定模式:
         - 传统锁定模式
            在此锁定模式下,所有类型的insert语句都会获得一个特殊的表级自增锁,多事务执行时并发性差
         - 连续锁定模式(MYSQL8.0前的默认模式)
            对于批量插入来说,连续锁定和传统锁定没有区别,每一次insert都会加锁,但是对于简单插入来说,因为事先是知道要插入多少条数据的,所以在获取了自增锁之后就可以得到需要的自增区间,然后
         就可以释放自增锁了,即需要获取一次自增锁来得到自增区间,但是真正的添加数据时并不需要持有自增锁,而是依靠一开始获取自增锁时获得的自增区间来实现数据插入;需要注意该模式下在最开始是
         需要获取自增锁的,所以如果自增锁此时被其他事务持有,那么即使是简单插入,此刻也会进入等待锁的阻塞状态;
         - 交错锁定模式(MYSQL8.0后的默认模式)
            在此模式下,所有类型的插入语句都不会持有自增锁,并发性max,自动递增值保证在所有并发执行的所有类型的insert语句中是唯一且单调递增的,
          但是由于多个语句可以同时生成数字,所以为任何给定语句插入的行生成的值可能不是连续的;
        三种锁定模式依赖于属性innodb_autoinc_lock_mode,0传统锁定、1连续锁定、2交错锁定;
　
    - 元数据锁
        无需显式使用,都是MYSQL自动加的;
        元数据锁意在保证读写的正确性;
        当我们对数据库进行增删改查时都会隐式的给我们当前的事务添加一个DML读锁,DML的读锁可以共享,所以可以多个事务对表进行查询,但如果我们想要修改表结构,实际上会为事务分配一个DML写锁,
      而这个DML写锁会阻塞其他试图获取DML读锁的事务,这是为了避免在一个事务中多次查询发现表结构都不同的尴尬情况;
        对一个表进行数据的增删改查时,加DML读锁;当对表的结构作出变更操作时,加DML写锁,DML读锁共享,DML写锁会阻塞DML读锁;
        注意这里纬度的区别,增删改查是对数据而并没有改变表结构,所以是DML读锁,只有对表结构做出了改变才会加DML写锁;












