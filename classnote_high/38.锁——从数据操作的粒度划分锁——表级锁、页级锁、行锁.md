从数据操作的粒度划分: 表级锁、页级锁、行锁

1.表锁
    该锁会锁定整张表,它是MYSQL中最基本的锁策略,并不依赖于存储引擎(无论你是MYSQL的什么存储引擎,对于表锁的策略都是一样的),并且表锁是开销最小的策略(因为粒度比较大),
  由于表级锁一次会将整个表锁定,所以可以很好的避免死锁的问题;当然,锁的粒度所带来的最大的负面影响就是出现锁资源争用的概率也会最高,导致并发率大打折扣;
　
    - 表级别的S锁、X锁
        一般情况下,不会使用到InnoDB存储引擎提供的表级别的S锁和X锁,InnoDB更厉害的还是更细粒度的行锁,关于表级别得X锁和S锁大概了解即可,[](/pdf/第15章_锁.pdf)
　
    - 意向锁
        InnoDB支持多粒度锁,它允许行级锁和表级锁共存,而意向锁就是其中一种表锁;在数据表的场景中,如果我们给一行数据加上了排它锁,数据库会自动给更大一级的空间,比如数据页或
      数据表加上意向锁,告诉其他人这个数据页或数据表已经有人上过排它锁了,这样当其他人想要获取数据表排它锁的时候,只需要了解是否有人已经获取了这个数据表的意向排他锁即可;
        意向锁是由存储引擎自己维护的,用户无法手动操作意向锁,在为数据行添加共享/排它锁时,InnoDB会自动添加该数据行所在数据表的对应意向锁;即如果我们给一行数据添加了一个
      共享锁/排它锁,实际上生成了两把锁,一把是我们声明的数据行的锁,另一个是InnoDB为我们生成的该数据行所在数据表的意向锁,我们添加的是排它锁,那么生成的就是意向排它锁,我们  
      声明的是共享锁,那么生成的就是意向共享锁;
　
      1)意向锁要解决的问题 
        现在有两个事务,分别是T1和T2,其中T2试图在该表级别上应用共享或排它锁,如果没有意向锁存在,那么T2就需要去检查每个页或行是否存在锁,效率很低;如果存在意向锁,那么此时
      就会受到由T1控制的表级别意向锁的阻塞,T2在锁定该表之前就不用检查各个页或行锁,而只需要检查表上的意向锁;
　
      2)意向锁的类型
         - 意向共享锁
         - 意向排它锁
　
      3)小结意向锁
         - InnoDB支持多粒度锁,特定场景下,行级锁可以与表级锁共存(行级排它锁和表级意向排他锁)
         - 意向锁之间互不排斥,但除了共享锁和意向共享锁之外,意向排它锁会与表级 共享锁/排它锁 互斥,意向共享锁也与排它锁互斥;
         - 意向锁是一种不与行级锁冲突的表级锁,意向共享锁和意向排他锁不会和行级的共享锁/排他锁发生冲突,只会与表级的共享锁/排他锁冲突;
         - 意向锁在保证并发性的前提下,实现了行锁和表锁共存且满足事务隔离性的要求;