1.数据页加载的三种方式
    - 内存读取
        如果该数据存在于内存中,基本上执行时间在1ms左右,即[内存中只单独读取一个页的效率是1ms/页]
    - 随机读取也叫随机IO
        如果数据没有在内存中,就需要在磁盘上对该页进行查找,整体预估时间在10ms左右,即[随机IO读取一个页的效率是10ms/页];这10ms中有6ms是
      磁盘的实际繁忙时间(包括了寻道和半圈旋转时间),有3ms是对可能发生的排队时间的估计值,另外还有1ms的传输时间;
    - 顺序读取也叫顺序IO
        顺序读取是一种批量读取的方式,因为我们请求的数据在磁盘上往往都是相邻存储的,顺序读取可以帮我们批量读取页面,这样的话,一次性加载到缓冲池
      中就不需要再对其他页面单独进行磁盘IO操作了;如果一个磁盘的吞吐量是40mb/s,那么对于一个16kb大小的页来说,一次可以顺序读取40mb/16kb即
      2560页,相当于[一个页的读取时间是1000/2560≈0.4ms/页];
    不难发现,如果仅就一个页而言,内存读取是最好的,顺序IO的速度也远远比随机IO快得多;如果数据量巨大,多个页时,顺序IO是最优解;

2.为什么要有区?
    B+树的每一层中的页都会形成一个双向链表,如果是以页为单位来分配存储空间的话,双向链表相邻的两个页之间的物理位置可能离得非常远;我们在介绍B+树
  索引的适用场景时特别提到范围查询只需要定位到最左边记录和最右边记录,然后沿着双向链表一直扫描就可以了;而如果链表中相邻的两个页物理位置距离很远,
  实际上就是随机IO了,随机IO是非常慢的,所以我们应尽量让链表中相邻的页的物理位置也相邻,这样进行范围查询的时候才可以使用顺序IO
    引入区的概念,一个区就是在物理位置上连续的64个页,因为InnoDB中的页大小默认是16KB,所以一个区的大小是64*16KB=1MB,在表中数据量大的时候,
  可以为某个索引分配空间的时候就不在按照页为单位分配了,而是按照区为单位分配,甚至在表中数据特别多的时候,可以一次性分配多个连续的区,虽然可能造成
  一点点空间的浪费(数据不足以填满整个区),但是从性能角度来看,可以消除很多随机IO,功大于过;

3.为什么要有段?
    对于范围查询,其实是对B+树叶子节点中的记录进行顺序扫描,而如果不区分叶子节点和非叶子节点,统统把节点代表的页面放到申请到的区中,进行范围查找的
  效率就大打折扣了(我个人的理解:因为范围查找时只需要先找到最大值和最小值,然后遍历就可以;而在查找最大最小值的时候,其实分为两步,先要在非叶子结点里
  找到符合范围的页,而这一步时其实大量的叶子节点就会干扰我们的查找速度)
    所以InnoDB中叶子结点和非叶子结点都有自己独有的区,而[存放叶子结点的区的集合就是一个段,通常我们称之为数据段],而[存放非叶子结点的区的集合也是
  一个段,通常我们称之为索引段];
    除了数据段和索引段之外,还有回滚段
    段并不对应表空间中某一个连续的物理区域,而是一个逻辑上的概念,由若干的零散的页面(这些零散的页面存放在碎片区中)以及一些完整的区组成

4.为什么要有碎片区?
    默认情况下,一个使用InnoDB存储引擎的表只有一个聚簇索引,一个索引会生成两个段(数据段,索引段),而段是以区为单位申请存储空间的,一个区默认占用
  1M(64*16kb=1024kb)存储空间,所以默认情况下一个只存了几条记录的小表也需要2M的存储空间吗？这对于存储记录比较少的表来说是巨大的浪费;
    这个问题的症结在于到目前为止我们介绍的区都是非常纯粹的,也就是一个区被整个分配给某一个段,或者说区中的所有页面都是为了存储同一个段的数据而存在,
  即使段的数据填不满区中的所有页面,那余下的页面也不能挪作他用;
    为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况,InnoDB提出了一个碎片区的概念;在一个碎片区中,并不是所有的页
  都是为了存储同一个段的数据而存在的,而是碎片区中的页可以用于不同的目的,比如有得页用于段A,有的页用于段B,有些页甚至哪个段都不属于;
    碎片区直属于表空间,并不属于任何一个段;
    所以此后为某个段分配存储空间的策略是这样的 
      - 在刚开始向表中插入数据的时候,段是从某个碎片区以单个页面为单位来分配存储空间的
      - 当某个段已经占用了32个碎片区页面之后,就会申请以完整的区为单位来分配存储空间
    所以现在段不能仅定义为是某些区的集合,更精确的应该是某些零散的页以及一些完整的区的集合

5.区的分类
    区大体上可以分为四种类型
      1.空闲的区: 还没有用到这个区中的任何页面
      2.有剩余空间的碎片区: 表示碎片区中还有可用的页
      3.没有剩余空间的碎片区: 表示碎片区中的所有页面都被使用,没有空闲页
      4.附属于某个段的区: 每一个索引都可以分为叶子节点和非叶子节点
    前三种状态的区都是独立的,只有最后一种状态的区是附属于某个段的
    
6.表空间
    表空间可以看作是InnoDB存储引擎逻辑结构的最高层,所有的数据都存放在表空间中
    表空间是一个逻辑容器,表空间存储的对象时段,在一个表空间中可以有一个或多个段,但是一个段只能属于一个表空间;表空间数据库由一个或多个表空间组成,
  表空间从管理上可以划分为系统表空间、独立表空间、撤销表空间和临时表空间

7.独立表空间
    独立表空间,即每张表有一个独立的表空间,也就是数据和索引信息都会保存在自己的表空间中;独立表空间可以在不同的数据库之间进行迁
  移空间可以回收(DROP TABLE后可以自动收回表空间,其他情况表空间不能自行回收);如果对于统计分析或日志表,删除大量数据后可以通过:
  (alter table TableName engine=innodb;) 来回收不用的空间;对于使用独立表空间的表,不管怎么删除,表空间的碎片不会太严重
  影响性能,而且还有机会处理   
    独立表空间最初占用空间很小,只有大概96KB,会随着数据的增多会逐渐增大

8.系统表空间
    系统表空间的结构和独立表空间基本类似,只不过由于整个MYSQL进程只有一个系统表空间,在系统表空间中会额外记录一些有关整个系统信息的页面,这部分
  是独立表空间中没有的;